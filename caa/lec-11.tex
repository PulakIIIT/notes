\chapter{Parallel algorithms, part 2}

\section{List Ranking}

\subsection{Making our algorithm better}
We want to make our algorithm better, we have a work complexity of $O(\log n)$
which we are trying to eliminate.

There are also some implementation issues. In the PRAM model, syncrhonous execution
means that all $n$ processors execute each step in parallel. So, we can have
inconsistent results!

How do we pick a list of size $n / \log n$? Our input is in the form of an array
of successor elements. So, we can't take equi-distant parts of the array,
since it won't be a valid sub-list anymore.


What we can do is to pick \textit{independent nodes}. Formally, we want
to remove an independent set: vertices that share no edge amongst them.

\begin{minted}{python}
1 -> (8) -> 5 -> 11 -> (2) -> 6 -> (10) -> 4 -> 3 -> (7) -> 12 -> 9
on removal:
1 -> 5 -> 11 -> 6 -> 4 -> 3 -> 12 -> 9
\end{minted}
We can remove \texttt{8, 2, 10, 7} in parallel.

We want to go to a subset of size $n / \log n$, but by removing independent
nodes, we can go smallest to $n / 2$.

\begin{minted}{python}
a -> (b) -> c -> (d) -> e -> (f) -> ...
\end{minted}
There are no other elements in the above chain we can add to the independent set.
So, we will need to repeat our process to reach $n / \log n$.

\section{Detour: Independent sets}
In a graph $G = (V, E)$, a subset of nodes $U \subseteq V$ is called an
\textit{independent set} if:
$$U~\text{is an independent set of G} \equiv \forall (u_1, u_2) \in U, u_1 \neq u_2 \implies (u_1, u_2) \notin E$$.

Linked lists, when viewed as graphs, have large independent sets.

\subsection{Technique: Symmetry breaking}
The idea is to look at a symmetric setting, and then induce differences
between them. Independent sets are symmetric, because given two nodes
that are neighbours, they're both eligible to be in the independent set 
(modulo other obstructions). This algorithm is applicable for graph coloring.

Usually, this technique requires randomization. However, there are special
cases where fast, deterministic symmetry breaking is possible. Linked lists
and directed cyclic graphs are examples where this is possible.

We first construct a symmetry-breaking based graph coloring solution,
which is then used to find independent sets.

\subsection{Coloring by Symmetry breaking}
Considered a directed cycle of $n$ nodes $0 \dots n-1$.

Assume we have 8 nodes, which are labeled using 3 bits. We may not have
consecutive numbering of our nodes, so we assume that our nodes are randomly
numbered, from 0 to 7 (3 bits).


\begin{itemize}
    \item Initially, treat each number as a color for the vertex.
    \item We can reduce the number of colors to $\log n$ in one step:
    \begin{itemize}
    \item Compare color with the parent. $Newcolor(u) = 2 k + color(u)[k]$.
    \item $k$ is the index of the first bit position from LSB where $color(u)$ and $color(parent(u))$ differ.
    \item So, $color(u)[k]$ is indexing the k-th bit of $color(u)$ starting from LSB.
    \item note that $0 \leq k \leq \log n - 1$.
    \item such a $k$ will always exist, since we are guaranteed some unique
    labelling of the vertices when we start this process.
    \end{itemize}
\end{itemize}

\begin{minted}{python}
u   | v   | new color (mostly 2 bits)
110 | 000 | 11 (k = 1)
000 | 100 | 100 (k = 2)
100 | 111 | 00 (k = 0)
010 | 001 | 00 (k = 0)
001 | 011 | 10 (k = 1)
011 | 101 | 11 (k = 1)
111 | 010 | 11 (k = 0)
101 | 110 | 01 (k = 0)
\end{minted}

\subsubsection{Correctness proof}
Suppose we have an edge $(u, v)$, where $newcolor(u) = newcolor(v)$.
Let $newcolor(u) = 2k + color(u)[k]$, and $newcolor(v) = 2r + color(v)[r]$.

If $newcolor(u) = newcolor(v)$, then $2k + color(u)[k] = 2r + color(v)[r]$.
Rearranging, we get that $2(r - k) = color(u)[k] - color(v)[k]$.


If $k = r$, then we get that $color(u)[k] = color(v)[k]$. But this cannot
happen, because by definition, $k$ is the bit where $u, v$ first differ!


If $k \neq r$, then we get that $2(r - k) = color(u)[k] - color(v)[k]$.
By comparing magnitudes, we see that $\big|color(u)[k] - color(v)[k]\big| \leq 1$
(since we're subtracting bit values), while $\big|2(r - k)\big| \geq 2$. 
This can't happen either for two equal values!


